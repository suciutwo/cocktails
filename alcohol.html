<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  stroke: #ccc;
}

.node text {
  pointer-events: none;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>
var color = d3.scale.linear()
    .domain([0, 1])
    .range(["blue", "red"]);
var width = 1200,
    height = 800,
    min_links = 1,
    max_links = 5,
    thresh = .2
    var loaded_data;
    

	
		

d3.json("alcohol.json", function(error, json) {

	   //This normalizes colors.   
	for (var i=0;i<json.nodes.length;i++)
	{ 
		var node_color = 0;
		for (var j=0;j<json.nodes.length;j++)
		{
			if(json.nodes[i].color > json.nodes[j].color)
			{
				node_color = node_color+1
			}
		}
	json.nodes[i].node_color = 1.*node_color/(json.nodes.length)
	}
	//This cleans up the links a little. 
	for (var i=0;i<json.nodes.length;i++)
	{ 
		var node_color = 0;
		for (var j=0;j<json.nodes.length;j++)
		{
			if(json.nodes[i].color > json.nodes[j].color)
			{
				node_color = node_color+1
			}
		}
	json.nodes[i].node_color = 1.*node_color/(json.nodes.length)
	json.nodes[i].index = i;
	}
	var link_strengths_by_node = {}
	for (var i=0;i<json.links.length;i++)
	{ 
		source = json.links[i]['source']
		target = json.links[i]['target']
		if(!(source in link_strengths_by_node))
			{
			link_strengths_by_node[source] = []
			}
		if(!(target in link_strengths_by_node))
			{
			link_strengths_by_node[target] = []
			}
		link_strengths_by_node[source].push(json.links[i]['value'])
		link_strengths_by_node[target].push(json.links[i]['value'])
	}
	var cutoffs_by_node = {}
	for(var key in link_strengths_by_node)
	{
		link_strengths_by_node[key].sort(function(a,b){return b-a});
		var cutoff = link_strengths_by_node[key][min_links -1]
		
		if(cutoff > thresh)
			{
				cutoff = Math.max(thresh, link_strengths_by_node[key][max_links-1])
			}
		cutoffs_by_node[key] = cutoff
		json.nodes[key].cutoff = cutoff;
	}
	
	var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
var force = d3.layout.force()
    .gravity(.05)
    .distance(function(d){ return 100;})
    .charge(-200)
    .linkStrength(function(d) {if((d.source.cluster == d.target.cluster)){return Math.min(d.value, 10000);} return 0;})
     .size([width, height]);
     
  force
      .nodes(json.nodes)
      .links(json.links)
      .start();
	
  var link = svg.selectAll(".link")
      .data(json.links)
    .enter().append("line")
      .attr("class", "link")
	.attr('opacity', function(d){if((d.source.cluster == d.target.cluster) ){return .5;} return 0;})
	.style("stroke", "grey")
  var node = svg.selectAll(".node")
      .data(json.nodes)
    .enter().append("g")
      .attr("class", "node")
      .call(force.drag);
      console.log(json.nodes.length)
 
	

  node.append("circle")
      .attr("r", function(d) { return 3+.01*Math.pow(d.size, .8)})
	.attr('fill', function(d) {return color(d.node_color);})
  node.append("text")
  .attr("dx", 0)
.attr("dy", function(d) { return  5+.01*Math.pow(d.size, .8)})
      .attr('text-anchor', 'middle')
	
      .attr('fill', 'black')
      .attr("font-size", "16")
      .attr("font-weight", "bold")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });
});

</script>